<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QCustomPlot: QCPGraph Class Reference</title>
<link href="qt.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class=header>
<a class=headerLink  href="index.html">Home</a> &middot;
<a class=headerLink  href="annotated.html">All Classes</a> &middot;
<a class=headerLink  href="functions_func.html">All Functions</a>
</div>
<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Functions</a>  </div>
  <div class="headertitle">
<h1>QCPGraph Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="QCPGraph" --><!-- doxytag: inherits="QCPAbstractPlottable" -->
<p>A plottable representing a graph in a plot.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for QCPGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classQCPGraph.png" usemap="#QCPGraph_map" alt=""/>
  <map id="QCPGraph_map" name="QCPGraph_map">
<area href="classQCPAbstractPlottable.html" alt="QCPAbstractPlottable" shape="rect" coords="0,0,134,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a> </td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0393a38cf7183cbf46348eb6cf9a5a6c">QCPGraph</a> (<a class="el" href="classQCPAxis.html">QCPAxis</a> *keyAxis, <a class="el" href="classQCPAxis.html">QCPAxis</a> *valueAxis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f4c17d993df4759c7426db45b33fbc0"></a><!-- doxytag: member="QCPGraph::data" ref="a8f4c17d993df4759c7426db45b33fbc0" args="() const " -->
const <a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6db8d31abeac256a285fc68d6b9b9be"></a><!-- doxytag: member="QCPGraph::lineStyle" ref="ad6db8d31abeac256a285fc68d6b9b9be" args="() const " -->
<a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lineStyle</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adff3ed4a1b62c9f6d7be9c347eeb4a2c"></a><!-- doxytag: member="QCPGraph::scatterStyle" ref="adff3ed4a1b62c9f6d7be9c347eeb4a2c" args="() const " -->
<a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scatterStyle</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d8e1e8affba4d443925b2e3e0d633c4"></a><!-- doxytag: member="QCPGraph::scatterSize" ref="a3d8e1e8affba4d443925b2e3e0d633c4" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>scatterSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb25d67dc6f85004d913ceb945beae3"></a><!-- doxytag: member="QCPGraph::scatterPixmap" ref="a1fb25d67dc6f85004d913ceb945beae3" args="() const " -->
const QPixmap&#160;</td><td class="memItemRight" valign="bottom"><b>scatterPixmap</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250bcdf78abac87bc6d46ee6fd99a92d"></a><!-- doxytag: member="QCPGraph::errorType" ref="a250bcdf78abac87bc6d46ee6fd99a92d" args="() const " -->
<a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>errorType</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83455e01093bb899f3b59d4a6fdcd57b"></a><!-- doxytag: member="QCPGraph::errorPen" ref="a83455e01093bb899f3b59d4a6fdcd57b" args="() const " -->
QPen&#160;</td><td class="memItemRight" valign="bottom"><b>errorPen</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31efdcbc6ba3d73a7aeb83c774f958a"></a><!-- doxytag: member="QCPGraph::errorBarSize" ref="ae31efdcbc6ba3d73a7aeb83c774f958a" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>errorBarSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04dbc050ff04561658ab1e7f3df37a01"></a><!-- doxytag: member="QCPGraph::errorBarSkipSymbol" ref="a04dbc050ff04561658ab1e7f3df37a01" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>errorBarSkipSymbol</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5369f23863e04a6164f8b66d49fd18f4"></a><!-- doxytag: member="QCPGraph::channelFillGraph" ref="a5369f23863e04a6164f8b66d49fd18f4" args="() const " -->
<a class="el" href="classQCPGraph.html">QCPGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>channelFillGraph</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a1df2fd710545c8ba3b2c99a39a27bf8b">setData</a> (<a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> *data, bool copy=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a4c55d8ac13bfa42c8c93747820891a76">setData</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abce9f07c0d722bc3e4fa7bd73c7e5dfa">setDataKeyError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac15c749c5fedf740d5692c6fe67143b8">setDataKeyError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#acba6296eadcb36b93267628b8dae3de5">setDataValueError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a3afbfd7222d739351c69387904776f93">setDataValueError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a873fe46bdb20be5710428e474ade8908">setDataBothError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError, const QVector&lt; double &gt; &amp;valueError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abb75736ecdbf6e6a7501e1da64fb18cf">setDataBothError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a> (<a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a> ls)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a> (<a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a> ss)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">setScatterSize</a> (double size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a80131c36eb134fbfb603951ef70e0a19">setScatterPixmap</a> (const QPixmap &amp;pixmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a> (<a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a> errorType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abd4c7f81939e10776ea64603a704f22a">setErrorPen</a> (const QPen &amp;pen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a10f50c5495ce45ef559ec2066194a335">setErrorBarSize</a> (double size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab1c1ee03d8dd94676a564e5e5f11aac2">setErrorBarSkipSymbol</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a2d03156df1b64037a2e36cfa50351ca3">setChannelFillGraph</a> (<a class="el" href="classQCPGraph.html">QCPGraph</a> *targetGraph)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a> (const <a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> &amp;dataMap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a80cc91e1e0ef77eb50afc5b366d0efd9">addData</a> (const <a class="el" href="classQCPData.html">QCPData</a> &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0bf98b1972286cfb7b1c4b7dd6ae2012">addData</a> (double key, double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab6da6377541fe80d892a9893a92db9c6">addData</a> (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a9fe0b3e54e8c7b61319bd03337e21e99">removeDataBefore</a> (double key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ae42d645ef617cfc75fc0df58e62c522a">removeDataAfter</a> (double key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> (double fromKey, double toKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a4a706020b4318f118381648ef18aca3f">removeData</a> (double key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#aa35b75b9032800d783df749c8a004ee9">rescaleAxes</a> (bool onlyEnlarge, bool includeErrorBars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a2108a729046b0ab6e0516afb249dab13">rescaleKeyAxis</a> (bool onlyEnlarge, bool includeErrorBars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a2ba0e1df416486d7e74299ef8cf68bba">rescaleValueAxis</a> (bool onlyEnlarge, bool includeErrorBars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af72c641a9ce6110b34ae129b66726ac9"></a><!-- doxytag: member="QCPGraph::parentPlot" ref="af72c641a9ce6110b34ae129b66726ac9" args="() const " -->
<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parentPlot</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1affc1972938e4364a9325e4e4e4dcea"></a><!-- doxytag: member="QCPGraph::name" ref="a1affc1972938e4364a9325e4e4e4dcea" args="() const " -->
QString&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3633ae45016e3fe5883d05bc7fc554ff"></a><!-- doxytag: member="QCPGraph::visible" ref="a3633ae45016e3fe5883d05bc7fc554ff" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>visible</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d060007cc6b3037c9c04d22d0c0398"></a><!-- doxytag: member="QCPGraph::pen" ref="a41d060007cc6b3037c9c04d22d0c0398" args="() const " -->
QPen&#160;</td><td class="memItemRight" valign="bottom"><b>pen</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa74cdceb9c7286ef116fbfa58e0326e7"></a><!-- doxytag: member="QCPGraph::brush" ref="aa74cdceb9c7286ef116fbfa58e0326e7" args="() const " -->
QBrush&#160;</td><td class="memItemRight" valign="bottom"><b>brush</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c7a09c22963f2c943f07112b311103"></a><!-- doxytag: member="QCPGraph::keyAxis" ref="a72c7a09c22963f2c943f07112b311103" args="() const " -->
<a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keyAxis</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3106f9d34d330a6097a8ec5905e5b519"></a><!-- doxytag: member="QCPGraph::valueAxis" ref="a3106f9d34d330a6097a8ec5905e5b519" args="() const " -->
<a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>valueAxis</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ab79c7ba76bc7fa89a4b3580e12149f1f">setName</a> (const QString &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a35c6325a2addc2e1a60b421c40357010">setVisible</a> (bool visible)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a> (const QPen &amp;pen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> (const QBrush &amp;brush)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a8524fa2994c63c0913ebd9bb2ffa3920">setKeyAxis</a> (<a class="el" href="classQCPAxis.html">QCPAxis</a> *axis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a71626a07367e241ec62ad2c34baf21cb">setValueAxis</a> (<a class="el" href="classQCPAxis.html">QCPAxis</a> *axis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a7e8fc3be43c27ccacd70a7bf9d74a5cd">rescaleAxes</a> (bool onlyEnlarge=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a1acecfcca3e7fcda00fcbaa3c886386f">rescaleKeyAxis</a> (bool onlyEnlarge=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#abfd0805eb1d955c0111a990246658324">rescaleValueAxis</a> (bool onlyEnlarge=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a495a73911dbd0333fd147fddd515f516">addToLegend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#aa1f350e510326d012b9a9c9249736c83">removeFromLegend</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a2687a9f6497750bd256586f69b4d34fe">draw</a> (QPainter *painter) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a5ec612e1729f285101cec941c66aee81">drawLegendIcon</a> (QPainter *painter, const QRect &amp;rect) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#af66183533a29520be3e74489ad1449cc">getPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0899c4d6357aee19a3abff5897c3c8c5">getScatterPlotData</a> (QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac76804eb33446181f3e4f708b7639a75">getLinePlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a6b7c14e04deed69b70d552dbe70c4d28">getStepLeftPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab2ad46716889c73ab977cf9280de0788">getStepRightPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac79dc75dd98db9948d9656447b463af5">getStepCenterPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0ff6e856387cc079b28592ead2a81f6c">getImpulsePlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a28c788f7b16ce04a6cad9080cc112e29">drawFill</a> (QPainter *painter, QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a> (QPainter *painter, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> (QPainter *painter, QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a58775ac57759c0db48b2f7dd53cd9279">drawImpulsePlot</a> (QPainter *painter, QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a48b100e35a9985784745dad8a4dc5855">drawScatter</a> (QPainter *painter, double x, double y, <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a> style) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a19701e3093b99373f7e7d4ad6328ff20">drawError</a> (QPainter *painter, double x, double y, const <a class="el" href="classQCPData.html">QCPData</a> &amp;data) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a8963c90087cf53b889b29dd59aa41aad">getVisibleDataBounds</a> (QCPDataMap::const_iterator &amp;lower, QCPDataMap::const_iterator &amp;upper, int &amp;count) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> (QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad31b49a90e91e538fd9caf011c913a68">removeFillBasePoints</a> (QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QPointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a> (double lowerKey) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QPointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a> (double upperKey) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QPolygonF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a> (const QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a6f4e9461d5925be9228fc4760249a04f">findIndexBelowX</a> (const QVector&lt; QPointF &gt; *data, double x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abab2a75b5e63630432bdd1f3b57f07fa">findIndexAboveX</a> (const QVector&lt; QPointF &gt; *data, double x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a6c4d556de3d1e02f548401001f72c6ff">findIndexBelowY</a> (const QVector&lt; QPointF &gt; *data, double y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#adf50243f1df203883a2187089734bfcb">findIndexAboveY</a> (const QVector&lt; QPointF &gt; *data, double y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab39c7e8c94b64804a8dc9c19bc7d4683">getKeyRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain=sdBoth) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a9fc0c1288455fa5bb64b603d6b01de6c">getValueRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain=sdBoth) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a3a69fbbaea30050a9cfe335a9a01cbf2">getKeyRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain, bool includeErrors) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#acdb1e7bb86fea2764b0adb104185832b">getValueRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain, bool includeErrors) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ade710a776104b14c1c835168ce1bfc5c">coordsToPixels</a> (double key, double value, double &amp;x, double &amp;y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QPointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a9fd1c9df8391781f05b0be22fbe91e13">coordsToPixels</a> (double key, double value) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A plottable representing a graph in a plot. </p>
<p>Usually <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> creates it internally via <a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a> and the resulting instance is accessed via <a class="el" href="classQCustomPlot.html#a6d3ed93c2bf46ab7fa670d66be4cddaf">QCustomPlot::graph</a>.</p>
<p>To plot data, assign it with the <a class="el" href="classQCPGraph.html#a1df2fd710545c8ba3b2c99a39a27bf8b">setData</a> or <a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a> functions.</p>
<h2><a class="anchor" id="appearance"></a>
Changing the appearance</h2>
<p>The appearance of the graph is mainly determined by the line style, scatter style, brush and pen of the graph (<a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a>, <a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a>, <a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a>, <a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a>).</p>
<h3><a class="anchor" id="filling"></a>
Filling under or between graphs</h3>
<p><a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot.">QCPGraph</a> knows two types of fills: Normal graph fills towards the zero-value-line parallel to the key axis of the graph, and fills between two graphs, called channel fills. To enable a fill, just set a brush with <a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> which is neither Qt::NoBrush nor fully transparent.</p>
<p>By default, a normal fill towards the zero-value-line will be drawn. To set up a channel fill between this graph and another one, call <a class="el" href="classQCPGraph.html#a2d03156df1b64037a2e36cfa50351ca3">setChannelFillGraph</a> with the other graph as parameter.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a>, <a class="el" href="classQCustomPlot.html#a6d3ed93c2bf46ab7fa670d66be4cddaf">QCustomPlot::graph</a>, QCPLegend::addGraph </dd></dl>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859"></a><!-- doxytag: member="QCPGraph::LineStyle" ref="ad60175cd9b5cac937c5ee685c32c0859" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">QCPGraph::LineStyle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how the graph's line is represented visually in the plot. The line is drawn with the current pen of the graph (<a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a>). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04"></a><!-- doxytag: member="lsNone" ref="ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04" args="" -->lsNone</em>&nbsp;</td><td>
<p>data points are not connected with any lines (e.g. data only represented with symbols according to the scatter style, see <a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a>) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859a3c42a27b15aa3c92d399082fad8b7515"></a><!-- doxytag: member="lsLine" ref="ad60175cd9b5cac937c5ee685c32c0859a3c42a27b15aa3c92d399082fad8b7515" args="" -->lsLine</em>&nbsp;</td><td>
<p>data points are connected by a straight line </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859ae10568bda57836487d9dec5eba1d6c6e"></a><!-- doxytag: member="lsStepLeft" ref="ad60175cd9b5cac937c5ee685c32c0859ae10568bda57836487d9dec5eba1d6c6e" args="" -->lsStepLeft</em>&nbsp;</td><td>
<p>line is drawn as steps where the step height is the value of the left data point </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859a9c37951f7d11aa070100fd16f2935c9e"></a><!-- doxytag: member="lsStepRight" ref="ad60175cd9b5cac937c5ee685c32c0859a9c37951f7d11aa070100fd16f2935c9e" args="" -->lsStepRight</em>&nbsp;</td><td>
<p>line is drawn as steps where the step height is the value of the right data point </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859a5adf7b04da215a40a764c21294ea7366"></a><!-- doxytag: member="lsStepCenter" ref="ad60175cd9b5cac937c5ee685c32c0859a5adf7b04da215a40a764c21294ea7366" args="" -->lsStepCenter</em>&nbsp;</td><td>
<p>line is drawn as steps where the step is in between two data points </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859aa3b358b4ae7cca94aceeb8e529c12ebb"></a><!-- doxytag: member="lsImpulse" ref="ad60175cd9b5cac937c5ee685c32c0859aa3b358b4ae7cca94aceeb8e529c12ebb" args="" -->lsImpulse</em>&nbsp;</td><td>
<p>data points are represented by a straight line parallel to the value axis, which ranges down/up to the key axis </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75"></a><!-- doxytag: member="QCPGraph::ScatterStyle" ref="afcb905e9cb11639aac825bd6c0c8ea75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">QCPGraph::ScatterStyle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This defines the visual appearance of the points, which are all drawn with the pen of the graph (<a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a>). The sizes of these visualizations (with exception of <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75af97f160593b2fa9902d1bb5afa796fe8">ssDot</a> and <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a68b421bb907a07d38b274d33a9fd1b9c">ssPixmap</a>) can be set with <a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">setScatterSize</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c"></a><!-- doxytag: member="ssNone" ref="afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c" args="" -->ssNone</em>&nbsp;</td><td>
<p>no scatter symbols are drawn (e.g. data only represented with lines, see <a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a>) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75af97f160593b2fa9902d1bb5afa796fe8"></a><!-- doxytag: member="ssDot" ref="afcb905e9cb11639aac825bd6c0c8ea75af97f160593b2fa9902d1bb5afa796fe8" args="" -->ssDot</em>&nbsp;</td><td>
<p>a single pixel, <a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">setScatterSize</a> has no influence on its size. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75aaee2c5bf5fb05ce2e6ba09b479599d50"></a><!-- doxytag: member="ssCross" ref="afcb905e9cb11639aac825bd6c0c8ea75aaee2c5bf5fb05ce2e6ba09b479599d50" args="" -->ssCross</em>&nbsp;</td><td>
<p>a cross (x) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a3c33d01d3a503714add5e545b79f7f7b"></a><!-- doxytag: member="ssPlus" ref="afcb905e9cb11639aac825bd6c0c8ea75a3c33d01d3a503714add5e545b79f7f7b" args="" -->ssPlus</em>&nbsp;</td><td>
<p>a plus (+) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75ae44053e76e45a9e974d020cd83cb94d0"></a><!-- doxytag: member="ssCircle" ref="afcb905e9cb11639aac825bd6c0c8ea75ae44053e76e45a9e974d020cd83cb94d0" args="" -->ssCircle</em>&nbsp;</td><td>
<p>a circle which is not filled </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a42c63834c064c781245e2f21c8f021d0"></a><!-- doxytag: member="ssDisc" ref="afcb905e9cb11639aac825bd6c0c8ea75a42c63834c064c781245e2f21c8f021d0" args="" -->ssDisc</em>&nbsp;</td><td>
<p>a circle which is filled with the color of the graph's pen (not the brush!) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75acb53d46a130594b3c6e37810462bbb02"></a><!-- doxytag: member="ssSquare" ref="afcb905e9cb11639aac825bd6c0c8ea75acb53d46a130594b3c6e37810462bbb02" args="" -->ssSquare</em>&nbsp;</td><td>
<p>a square which is not filled </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a68ef17715bd12021e8f4697f94e4dba3"></a><!-- doxytag: member="ssStar" ref="afcb905e9cb11639aac825bd6c0c8ea75a68ef17715bd12021e8f4697f94e4dba3" args="" -->ssStar</em>&nbsp;</td><td>
<p>a star with eight arms, i.e. a combination of cross and plus </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75ad2478c8157f45eecd4214a682fefc265"></a><!-- doxytag: member="ssTriangle" ref="afcb905e9cb11639aac825bd6c0c8ea75ad2478c8157f45eecd4214a682fefc265" args="" -->ssTriangle</em>&nbsp;</td><td>
<p>an equilateral triangle which is not filled, standing on baseline </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75abbedc89538690e692231183076c379e1"></a><!-- doxytag: member="ssTriangleInverted" ref="afcb905e9cb11639aac825bd6c0c8ea75abbedc89538690e692231183076c379e1" args="" -->ssTriangleInverted</em>&nbsp;</td><td>
<p>an equilateral triangle which is not filled, standing on corner </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a3d82ca5a24da838a8c84810529b864d5"></a><!-- doxytag: member="ssCrossSquare" ref="afcb905e9cb11639aac825bd6c0c8ea75a3d82ca5a24da838a8c84810529b864d5" args="" -->ssCrossSquare</em>&nbsp;</td><td>
<p>a square which is not filled, with a cross inside </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a4c9c2dc5d54e5c8b87462440d857df40"></a><!-- doxytag: member="ssPlusSquare" ref="afcb905e9cb11639aac825bd6c0c8ea75a4c9c2dc5d54e5c8b87462440d857df40" args="" -->ssPlusSquare</em>&nbsp;</td><td>
<p>a square which is not filled, with a plus inside </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a0cf2f18f8dba6352403bd7c6262a7972"></a><!-- doxytag: member="ssCrossCircle" ref="afcb905e9cb11639aac825bd6c0c8ea75a0cf2f18f8dba6352403bd7c6262a7972" args="" -->ssCrossCircle</em>&nbsp;</td><td>
<p>a circle which is not filled, with a cross inside </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a1e916f6b02f20f32ce5e15a699460bb4"></a><!-- doxytag: member="ssPlusCircle" ref="afcb905e9cb11639aac825bd6c0c8ea75a1e916f6b02f20f32ce5e15a699460bb4" args="" -->ssPlusCircle</em>&nbsp;</td><td>
<p>a circle which is not filled, with a plus inside </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a1d77a1079282bc2c1af37b708b5da46c"></a><!-- doxytag: member="ssPeace" ref="afcb905e9cb11639aac825bd6c0c8ea75a1d77a1079282bc2c1af37b708b5da46c" args="" -->ssPeace</em>&nbsp;</td><td>
<p>a circle which is not filled, with one vertical and two downward diagonal lines </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcb905e9cb11639aac825bd6c0c8ea75a68b421bb907a07d38b274d33a9fd1b9c"></a><!-- doxytag: member="ssPixmap" ref="afcb905e9cb11639aac825bd6c0c8ea75a68b421bb907a07d38b274d33a9fd1b9c" args="" -->ssPixmap</em>&nbsp;</td><td>
<p>a custom pixmap specified by setScatterPixmap, centered on the data point coordinates. <a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">setScatterSize</a> has no influence on its size. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad23b514404bd2cb3216f57c90904d6af"></a><!-- doxytag: member="QCPGraph::ErrorType" ref="ad23b514404bd2cb3216f57c90904d6af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">QCPGraph::ErrorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines what kind of error bars are drawn for each data point </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afaeae745e7cc1766bb8546e35d4b76a711"></a><!-- doxytag: member="etNone" ref="ad23b514404bd2cb3216f57c90904d6afaeae745e7cc1766bb8546e35d4b76a711" args="" -->etNone</em>&nbsp;</td><td>
<p>No error bars are shown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afa2a5d89cd76fb8b6b18d71b8f6f6c0f43"></a><!-- doxytag: member="etKey" ref="ad23b514404bd2cb3216f57c90904d6afa2a5d89cd76fb8b6b18d71b8f6f6c0f43" args="" -->etKey</em>&nbsp;</td><td>
<p>Error bars for the key dimension of the data point are shown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afa147022ccdc49f6bd48f904cb4f61872e"></a><!-- doxytag: member="etValue" ref="ad23b514404bd2cb3216f57c90904d6afa147022ccdc49f6bd48f904cb4f61872e" args="" -->etValue</em>&nbsp;</td><td>
<p>Error bars for the value dimension of the data point are shown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afa761cb7d61670c1e2efecccd8974409ab"></a><!-- doxytag: member="etBoth" ref="ad23b514404bd2cb3216f57c90904d6afa761cb7d61670c1e2efecccd8974409ab" args="" -->etBoth</em>&nbsp;</td><td>
<p>Error bars for both key and value dimensions of the data point are shown. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8"></a><!-- doxytag: member="QCPGraph::SignDomain" ref="a661743478a1d3c09d28ec2711d7653d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">QCPAbstractPlottable::SignDomain</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents negative and positive sign domain for passing to <a class="el" href="classQCPAbstractPlottable.html#a7aa24ed0b3c39bd99338c7b9f145a71b">getKeyRange</a> and <a class="el" href="classQCPAbstractPlottable.html#aed35cfebe5546feea7af2638dd869d5f">getValueRange</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63"></a><!-- doxytag: member="sdNegative" ref="a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63" args="" -->sdNegative</em>&nbsp;</td><td>
<p>The negative sign domain, i.e. numbers smaller than zero. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60"></a><!-- doxytag: member="sdBoth" ref="a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60" args="" -->sdBoth</em>&nbsp;</td><td>
<p>Both sign domains, including zero, i.e. all (rational) numbers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030"></a><!-- doxytag: member="sdPositive" ref="a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030" args="" -->sdPositive</em>&nbsp;</td><td>
<p>The positive sign domain, i.e. numbers greater than zero. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0393a38cf7183cbf46348eb6cf9a5a6c"></a><!-- doxytag: member="QCPGraph::QCPGraph" ref="a0393a38cf7183cbf46348eb6cf9a5a6c" args="(QCPAxis *keyAxis, QCPAxis *valueAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QCPGraph::QCPGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>keyAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>valueAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs a graph which uses <em>keyAxis</em> as its key axis ("x") and <em>valueAxis</em> as its value axis ("y"). <em>keyAxis</em> and <em>valueAxis</em> must both reside in the same <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>.</p>
<p>The constructed <a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot.">QCPGraph</a> can be added to the plot with <a class="el" href="classQCustomPlot.html#ab7ad9174f701f9c6f64e378df77927a6">QCustomPlot::addPlottable</a>, <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> then takes ownership of the graph.</p>
<p>To directly create a graph inside a plot, you can also use the simpler <a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a> function. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1df2fd710545c8ba3b2c99a39a27bf8b"></a><!-- doxytag: member="QCPGraph::setData" ref="a1df2fd710545c8ba3b2c99a39a27bf8b" args="(QCPDataMap *data, bool copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided <em>data</em>.</p>
<p>If <em>copy</em> is set to true, data points in <em>data</em> will only be copied. if false, the plottable takes ownership of the passed data and replaces the internal data pointer with it. This is significantly faster than copying for large datasets. </p>

</div>
</div>
<a class="anchor" id="a4c55d8ac13bfa42c8c93747820891a76"></a><!-- doxytag: member="QCPGraph::setData" ref="a4c55d8ac13bfa42c8c93747820891a76" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setData </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="abce9f07c0d722bc3e4fa7bd73c7e5dfa"></a><!-- doxytag: member="QCPGraph::setDataKeyError" ref="abce9f07c0d722bc3e4fa7bd73c7e5dfa" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setDataKeyError </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the symmetrical key error of the data points are set to the values in <em>keyError</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="ac15c749c5fedf740d5692c6fe67143b8"></a><!-- doxytag: member="QCPGraph::setDataKeyError" ref="ac15c749c5fedf740d5692c6fe67143b8" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setDataKeyError </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorPlus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the negative key error of the data points are set to the values in <em>keyErrorMinus</em>, the positive key error to <em>keyErrorPlus</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="acba6296eadcb36b93267628b8dae3de5"></a><!-- doxytag: member="QCPGraph::setDataValueError" ref="acba6296eadcb36b93267628b8dae3de5" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setDataValueError </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the symmetrical value error of the data points are set to the values in <em>valueError</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="a3afbfd7222d739351c69387904776f93"></a><!-- doxytag: member="QCPGraph::setDataValueError" ref="a3afbfd7222d739351c69387904776f93" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setDataValueError </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorPlus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the negative value error of the data points are set to the values in <em>valueErrorMinus</em>, the positive value error to <em>valueErrorPlus</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="a873fe46bdb20be5710428e474ade8908"></a><!-- doxytag: member="QCPGraph::setDataBothError" ref="a873fe46bdb20be5710428e474ade8908" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError, const QVector&lt; double &gt; &amp;valueError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setDataBothError </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the symmetrical key and value errors of the data points are set to the values in <em>keyError</em> and <em>valueError</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="abb75736ecdbf6e6a7501e1da64fb18cf"></a><!-- doxytag: member="QCPGraph::setDataBothError" ref="abb75736ecdbf6e6a7501e1da64fb18cf" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setDataBothError </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorPlus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorPlus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the negative key and value errors of the data points are set to the values in <em>keyErrorMinus</em> and <em>valueErrorMinus</em>. The positive key and value errors are set to the values in <em>keyErrorPlus</em> <em>valueErrorPlus</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="a513fecccff5b2a50ce53f665338c60ff"></a><!-- doxytag: member="QCPGraph::setLineStyle" ref="a513fecccff5b2a50ce53f665338c60ff" args="(LineStyle ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setLineStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a>&#160;</td>
          <td class="paramname"><em>ls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets how the single data points are connected in the plot or how they are represented visually apart from the scatter symbol. For scatter-only plots, set <em>ls</em> to <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a> and <a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a> to the desired scatter style. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbc13d2ff1c5edc4a3d9e7e9097e2b23"></a><!-- doxytag: member="QCPGraph::setScatterStyle" ref="abbc13d2ff1c5edc4a3d9e7e9097e2b23" args="(ScatterStyle ss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setScatterStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a>&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the visual appearance of single data points in the plot. If set to <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>, no scatter points are drawn (e.g. for line-only-plots with appropriate line style). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a>, <a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70d5c6058096797a227e6827ff743d89"></a><!-- doxytag: member="QCPGraph::setScatterSize" ref="a70d5c6058096797a227e6827ff743d89" args="(double size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setScatterSize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This defines how big (in pixels) single scatters are drawn, if scatter style (<a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a>) isn't <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>, <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75af97f160593b2fa9902d1bb5afa796fe8">ssDot</a> or <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a68b421bb907a07d38b274d33a9fd1b9c">ssPixmap</a>. Floating point values are allowed for fine grained control over optical appearance with antialiased painting. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a80131c36eb134fbfb603951ef70e0a19"></a><!-- doxytag: member="QCPGraph::setScatterPixmap" ref="a80131c36eb134fbfb603951ef70e0a19" args="(const QPixmap &amp;pixmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setScatterPixmap </td>
          <td>(</td>
          <td class="paramtype">const QPixmap &amp;&#160;</td>
          <td class="paramname"><em>pixmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the scatter style (<a class="el" href="classQCPGraph.html#abbc13d2ff1c5edc4a3d9e7e9097e2b23">setScatterStyle</a>) is set to ssPixmap, this function defines the QPixmap that will be drawn centered on the data point coordinate. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac3614d799c3894f2bc646e99c7f73d38"></a><!-- doxytag: member="QCPGraph::setErrorType" ref="ac3614d799c3894f2bc646e99c7f73d38" args="(ErrorType errorType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setErrorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a>&#160;</td>
          <td class="paramname"><em>errorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd4c7f81939e10776ea64603a704f22a"></a><!-- doxytag: member="QCPGraph::setErrorPen" ref="abd4c7f81939e10776ea64603a704f22a" args="(const QPen &amp;pen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setErrorPen </td>
          <td>(</td>
          <td class="paramtype">const QPen &amp;&#160;</td>
          <td class="paramname"><em>pen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the pen with which the error bars will be drawn. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a10f50c5495ce45ef559ec2066194a335">setErrorBarSize</a>, <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10f50c5495ce45ef559ec2066194a335"></a><!-- doxytag: member="QCPGraph::setErrorBarSize" ref="a10f50c5495ce45ef559ec2066194a335" args="(double size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setErrorBarSize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the width of the handles at both ends of an error bar in pixels. </p>

</div>
</div>
<a class="anchor" id="ab1c1ee03d8dd94676a564e5e5f11aac2"></a><!-- doxytag: member="QCPGraph::setErrorBarSkipSymbol" ref="ab1c1ee03d8dd94676a564e5e5f11aac2" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setErrorBarSkipSymbol </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If <em>enabled</em> is set to true, the error bar will not be drawn as a solid line under the scatter symbol but leave some free space around the symbol.</p>
<p>This feature uses the current scatter size (<a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">setScatterSize</a>) to determine the size of the area to leave blank. So when drawing Pixmaps as scatter points (<a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a68b421bb907a07d38b274d33a9fd1b9c">ssPixmap</a>), the scatter size must be set manually to a value corresponding to the size of the Pixmap, if the error bars should leave gaps to its boundaries. </p>

</div>
</div>
<a class="anchor" id="a2d03156df1b64037a2e36cfa50351ca3"></a><!-- doxytag: member="QCPGraph::setChannelFillGraph" ref="a2d03156df1b64037a2e36cfa50351ca3" args="(QCPGraph *targetGraph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::setChannelFillGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html">QCPGraph</a> *&#160;</td>
          <td class="paramname"><em>targetGraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the target graph for filling the area between this graph and <em>targetGraph</em> with the current brush (<a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a>).</p>
<p>When <em>targetGraph</em> is set to 0, a normal graph fill will be produced. This means, when the brush is not Qt::NoBrush or fully transparent, a fill all the way to the zero-value-line parallel to the key axis of this graph will be drawn. To disable any filling, set the brush to Qt::NoBrush. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5c6181d84db72ce4dbe9dc15a34ef4f"></a><!-- doxytag: member="QCPGraph::addData" ref="aa5c6181d84db72ce4dbe9dc15a34ef4f" args="(const QCPDataMap &amp;dataMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::addData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> &amp;&#160;</td>
          <td class="paramname"><em>dataMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds the provided data points in <em>dataMap</em> to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a80cc91e1e0ef77eb50afc5b366d0efd9"></a><!-- doxytag: member="QCPGraph::addData" ref="a80cc91e1e0ef77eb50afc5b366d0efd9" args="(const QCPData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::addData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCPData.html">QCPData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Adds the provided single data point in <em>data</em> to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf98b1972286cfb7b1c4b7dd6ae2012"></a><!-- doxytag: member="QCPGraph::addData" ref="a0bf98b1972286cfb7b1c4b7dd6ae2012" args="(double key, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::addData </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Adds the provided single data point as <em>key</em> and <em>value</em> pair to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6da6377541fe80d892a9893a92db9c6"></a><!-- doxytag: member="QCPGraph::addData" ref="ab6da6377541fe80d892a9893a92db9c6" args="(const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::addData </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Adds the provided data points as <em>key</em> and <em>value</em> pairs to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9fe0b3e54e8c7b61319bd03337e21e99"></a><!-- doxytag: member="QCPGraph::removeDataBefore" ref="a9fe0b3e54e8c7b61319bd03337e21e99" args="(double key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::removeDataBefore </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points with keys smaller than <em>key</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae42d645ef617cfc75fc0df58e62c522a"></a><!-- doxytag: member="QCPGraph::removeDataAfter" ref="ae42d645ef617cfc75fc0df58e62c522a" args="(double key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::removeDataAfter </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points with keys greater than <em>key</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a0fde50b7db9db0a85b5c5b6b10098f"></a><!-- doxytag: member="QCPGraph::removeData" ref="a4a0fde50b7db9db0a85b5c5b6b10098f" args="(double fromKey, double toKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::removeData </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fromKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points with keys between <em>fromKey</em> and <em>toKey</em>. if <em>fromKey</em> is greater or equal to <em>toKey</em>, the function does nothing. To remove a single data point with known key, use <a class="el" href="classQCPGraph.html#a4a706020b4318f118381648ef18aca3f">removeData(double key)</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a706020b4318f118381648ef18aca3f"></a><!-- doxytag: member="QCPGraph::removeData" ref="a4a706020b4318f118381648ef18aca3f" args="(double key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::removeData </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Removes a single data point at <em>key</em>. If the position is not known with absolute precision, consider using <a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData(double fromKey, double toKey)</a> with a small fuzziness interval around the suspected position, depeding on the precision with which the key is known.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e94a4e44e5e76fbec81a72a977157d"></a><!-- doxytag: member="QCPGraph::clearData" ref="ad4e94a4e44e5e76fbec81a72a977157d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::clearData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a>, <a class="el" href="classQCPGraph.html#ae42d645ef617cfc75fc0df58e62c522a">removeDataAfter</a>, <a class="el" href="classQCPGraph.html#a9fe0b3e54e8c7b61319bd03337e21e99">removeDataBefore</a> </dd></dl>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#a86e5b8fd4b6ff4f4084e7ea4c573fc53">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="aa35b75b9032800d783df749c8a004ee9"></a><!-- doxytag: member="QCPGraph::rescaleAxes" ref="aa35b75b9032800d783df749c8a004ee9" args="(bool onlyEnlarge, bool includeErrorBars) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::rescaleAxes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrorBars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to define whether error bars are taken into consideration when determining the new axis range. </p>

</div>
</div>
<a class="anchor" id="a2108a729046b0ab6e0516afb249dab13"></a><!-- doxytag: member="QCPGraph::rescaleKeyAxis" ref="a2108a729046b0ab6e0516afb249dab13" args="(bool onlyEnlarge, bool includeErrorBars) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::rescaleKeyAxis </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrorBars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to define whether error bars (of kind <a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6afa2a5d89cd76fb8b6b18d71b8f6f6c0f43">QCPGraph::etKey</a>) are taken into consideration when determining the new axis range. </p>

</div>
</div>
<a class="anchor" id="a2ba0e1df416486d7e74299ef8cf68bba"></a><!-- doxytag: member="QCPGraph::rescaleValueAxis" ref="a2ba0e1df416486d7e74299ef8cf68bba" args="(bool onlyEnlarge, bool includeErrorBars) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::rescaleValueAxis </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrorBars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to define whether error bars (of kind <a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6afa147022ccdc49f6bd48f904cb4f61872e">QCPGraph::etValue</a>) are taken into consideration when determining the new axis range. </p>

</div>
</div>
<a class="anchor" id="a2687a9f6497750bd256586f69b4d34fe"></a><!-- doxytag: member="QCPGraph::draw" ref="a2687a9f6497750bd256586f69b4d34fe" args="(QPainter *painter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::draw </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws this plottable with the provided <em>painter</em>. Called by <a class="el" href="classQCustomPlot.html#a036140935229490330abe492a47d9a63">QCustomPlot::draw</a> on all its plottables. </p>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#a2a2d489f55fcf11280d83be3a5324238">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a5ec612e1729f285101cec941c66aee81"></a><!-- doxytag: member="QCPGraph::drawLegendIcon" ref="a5ec612e1729f285101cec941c66aee81" args="(QPainter *painter, const QRect &amp;rect) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::drawLegendIcon </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QRect &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by <a class="el" href="classQCPLegend.html#a6c3aab12e835d46df503032c812b5e1d">QCPLegend::draw</a> (via <a class="el" href="classQCPPlottableLegendItem.html#aa7d0ab4cae7615ccb9fb6ff72d973de3">QCPPlottableLegendItem::draw</a>) to create a graphical representation of this plottable inside <em>rect</em>, next to the plottable name. </p>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#af26c6beea04c56a22a5549dc388a347a">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="af66183533a29520be3e74489ad1449cc"></a><!-- doxytag: member="QCPGraph::getPlotData" ref="af66183533a29520be3e74489ad1449cc" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getPlotData </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function branches out to the line style specific "get(...)PlotData" functions, according to the line style of the graph. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lineData</td><td>will be filled with raw points that will be drawn with the according draw functions, e.g. <a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> and <a class="el" href="classQCPGraph.html#a58775ac57759c0db48b2f7dd53cd9279">drawImpulsePlot</a>. These aren't necessarily the original data points, since for step plots for example, additional points are needed for drawing lines that make up steps. If the line style of the graph is <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a>, the <em>lineData</em> vector will be left untouched. </td></tr>
    <tr><td class="paramname">pointData</td><td>will be filled with the original data points so <a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a> can draw the scatter symbols accordingly. If no scatters need to be drawn, i.e. scatter style is <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>, pass 0 as <em>pointData</em>, and this step will be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a0899c4d6357aee19a3abff5897c3c8c5">getScatterPlotData</a>, <a class="el" href="classQCPGraph.html#ac76804eb33446181f3e4f708b7639a75">getLinePlotData</a>, <a class="el" href="classQCPGraph.html#a6b7c14e04deed69b70d552dbe70c4d28">getStepLeftPlotData</a>, <a class="el" href="classQCPGraph.html#ab2ad46716889c73ab977cf9280de0788">getStepRightPlotData</a>, <a class="el" href="classQCPGraph.html#ac79dc75dd98db9948d9656447b463af5">getStepCenterPlotData</a>, <a class="el" href="classQCPGraph.html#a0ff6e856387cc079b28592ead2a81f6c">getImpulsePlotData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0899c4d6357aee19a3abff5897c3c8c5"></a><!-- doxytag: member="QCPGraph::getScatterPlotData" ref="a0899c4d6357aee19a3abff5897c3c8c5" args="(QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getScatterPlotData </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If line style is <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a> and scatter style is not <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>, this function serves at providing the visible data points in <em>pointData</em>, so the <a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a> function can draw the scatter points accordingly.</p>
<p>If line style is not <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a>, this function is not called and the data for the scatter points are (if needed) calculated inside the corresponding other "get(...)PlotData" functions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac76804eb33446181f3e4f708b7639a75"></a><!-- doxytag: member="QCPGraph::getLinePlotData" ref="ac76804eb33446181f3e4f708b7639a75" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getLinePlotData </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a normal linearly connected plot in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7c14e04deed69b70d552dbe70c4d28"></a><!-- doxytag: member="QCPGraph::getStepLeftPlotData" ref="a6b7c14e04deed69b70d552dbe70c4d28" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getStepLeftPlotData </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a step plot with left oriented steps in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab2ad46716889c73ab977cf9280de0788"></a><!-- doxytag: member="QCPGraph::getStepRightPlotData" ref="ab2ad46716889c73ab977cf9280de0788" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getStepRightPlotData </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a step plot with right oriented steps in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac79dc75dd98db9948d9656447b463af5"></a><!-- doxytag: member="QCPGraph::getStepCenterPlotData" ref="ac79dc75dd98db9948d9656447b463af5" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getStepCenterPlotData </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a step plot with centered steps in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ff6e856387cc079b28592ead2a81f6c"></a><!-- doxytag: member="QCPGraph::getImpulsePlotData" ref="a0ff6e856387cc079b28592ead2a81f6c" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getImpulsePlotData </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for an impulse plot in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a58775ac57759c0db48b2f7dd53cd9279">drawImpulsePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a28c788f7b16ce04a6cad9080cc112e29"></a><!-- doxytag: member="QCPGraph::drawFill" ref="a28c788f7b16ce04a6cad9080cc112e29" args="(QPainter *painter, QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::drawFill </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws the fill of the graph with the specified brush. If the fill is a normal "base" fill, i.e. under the graph toward the zero-value-line, only the <em>lineData</em> is required (and two extra points at the zero-value-line, which are added by <a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> and removed by <a class="el" href="classQCPGraph.html#ad31b49a90e91e538fd9caf011c913a68">removeFillBasePoints</a> after the fill drawing is done).</p>
<p>If the fill is a channel fill between this graph and another graph (mChannelFillGraph), the more complex polygon is calculated with the <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a> function. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0e6ee90516b2e461431f8ca903c9e51e"></a><!-- doxytag: member="QCPGraph::drawScatterPlot" ref="a0e6ee90516b2e461431f8ca903c9e51e" args="(QPainter *painter, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::drawScatterPlot </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws scatter symbols at every data point passed in <em>pointData</em>. scatter symbols are independent of the line style and are always drawn if scatter style is not <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a741114539b2b051df6322bd36009ed3c">ssNone</a>. Hence, the <em>pointData</em> vector is outputted by all "get(...)PlotData" functions, together with the (line style dependent) line data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a>, <a class="el" href="classQCPGraph.html#a58775ac57759c0db48b2f7dd53cd9279">drawImpulsePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab3a52987895deb748922281ca3872e3b"></a><!-- doxytag: member="QCPGraph::drawLinePlot" ref="ab3a52987895deb748922281ca3872e3b" args="(QPainter *painter, QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::drawLinePlot </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws line graphs from the provided data. It connects all points in <em>lineData</em>, which was created by one of the "get(...)PlotData" functions for line styles that require simple line connections between the point vector they create. These are for example <a class="el" href="classQCPGraph.html#ac76804eb33446181f3e4f708b7639a75">getLinePlotData</a>, <a class="el" href="classQCPGraph.html#a6b7c14e04deed69b70d552dbe70c4d28">getStepLeftPlotData</a>, <a class="el" href="classQCPGraph.html#ab2ad46716889c73ab977cf9280de0788">getStepRightPlotData</a> and <a class="el" href="classQCPGraph.html#ac79dc75dd98db9948d9656447b463af5">getStepCenterPlotData</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a>, <a class="el" href="classQCPGraph.html#a58775ac57759c0db48b2f7dd53cd9279">drawImpulsePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a58775ac57759c0db48b2f7dd53cd9279"></a><!-- doxytag: member="QCPGraph::drawImpulsePlot" ref="a58775ac57759c0db48b2f7dd53cd9279" args="(QPainter *painter, QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::drawImpulsePlot </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws impulses graphs from the provided data, i.e. it connects all line pairs in <em>lineData</em>, which was created by <a class="el" href="classQCPGraph.html#a0ff6e856387cc079b28592ead2a81f6c">getImpulsePlotData</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a>, <a class="el" href="classQCPGraph.html#ab3a52987895deb748922281ca3872e3b">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a48b100e35a9985784745dad8a4dc5855"></a><!-- doxytag: member="QCPGraph::drawScatter" ref="a48b100e35a9985784745dad8a4dc5855" args="(QPainter *painter, double x, double y, ScatterStyle style) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::drawScatter </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75">ScatterStyle</a>&#160;</td>
          <td class="paramname"><em>style</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called by the scatter plot drawing function (<a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a>) to draw single point representations at the pixel positions <em>x</em> and <em>y</em> in the scatter style <em>style</em>.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>this function changes the brush of the painter for scatter styles <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75ae44053e76e45a9e974d020cd83cb94d0">ssCircle</a>, <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75a42c63834c064c781245e2f21c8f021d0">ssDisc</a> and <a class="el" href="classQCPGraph.html#afcb905e9cb11639aac825bd6c0c8ea75acb53d46a130594b3c6e37810462bbb02">ssSquare</a> in order to draw clear (ssSquare, ssCircle) and filled (ssDisc) shapes. </dd></dl>

</div>
</div>
<a class="anchor" id="a19701e3093b99373f7e7d4ad6328ff20"></a><!-- doxytag: member="QCPGraph::drawError" ref="a19701e3093b99373f7e7d4ad6328ff20" args="(QPainter *painter, double x, double y, const QCPData &amp;data) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::drawError </td>
          <td>(</td>
          <td class="paramtype">QPainter *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQCPData.html">QCPData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by the scatter drawing function (<a class="el" href="classQCPGraph.html#a0e6ee90516b2e461431f8ca903c9e51e">drawScatterPlot</a>) to draw the error bars on one data point. <em>x</em> and <em>y</em> pixel positions of the data point are passed since they are already known in pixel coordinates in the drawing function, so we save some extra coordToPixel transforms here. <em>data</em> is therefore only used for the errors, not key and value. </p>

</div>
</div>
<a class="anchor" id="a8963c90087cf53b889b29dd59aa41aad"></a><!-- doxytag: member="QCPGraph::getVisibleDataBounds" ref="a8963c90087cf53b889b29dd59aa41aad" args="(QCPDataMap::const_iterator &amp;lower, QCPDataMap::const_iterator &amp;upper, int &amp;count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::getVisibleDataBounds </td>
          <td>(</td>
          <td class="paramtype">QCPDataMap::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QCPDataMap::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by the specific plot data generating functions "get(...)PlotData" to determine which data range is visible, so only that needs to be processed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lower</td><td>returns an iterator to the lowest data point that needs to be taken into account when plotting. Note that in order to get a clean plot all the way to the edge of the axes, <em>lower</em> may still be outside the visible range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper</td><td>returns an iterator to the highest data point. Same as before, <em>upper</em> may also lie outside of the visible range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>number of data points that need plotting, i.e. points between <em>lower</em> and <em>upper</em>, including them. This is useful for allocating the array of QPointFs in the specific drawing functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fa7884620d7c54b81dfbd255d97b636"></a><!-- doxytag: member="QCPGraph::addFillBasePoints" ref="a5fa7884620d7c54b81dfbd255d97b636" args="(QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::addFillBasePoints </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The line data vector generated by e.g. getLinePlotData contains only the line that connects the data points. If the graph needs to be filled, two additional points need to be added at the value-zero-line in the lower and upper key positions, the graph reaches. This function calculates these points and adds them to the end of <em>lineData</em>. Since the fill is typically drawn before the line stroke, these added points need to be removed again after the fill is done, with the removeFillBasePoints function.</p>
<p>The expanding of <em>lineData</em> by two points will not cause unnecessary memory reallocations, because the data vector generation functions (getLinePlotData etc.) reserve two extra points when they allocate memory for <em>lineData</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ad31b49a90e91e538fd9caf011c913a68">removeFillBasePoints</a>, <a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad31b49a90e91e538fd9caf011c913a68"></a><!-- doxytag: member="QCPGraph::removeFillBasePoints" ref="ad31b49a90e91e538fd9caf011c913a68" args="(QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPGraph::removeFillBasePoints </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removes the two points from <em>lineData</em> that were added by addFillBasePoints. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a>, <a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a41f982e8ceaefe6a53eb7432f26d64b6"></a><!-- doxytag: member="QCPGraph::lowerFillBasePoint" ref="a41f982e8ceaefe6a53eb7432f26d64b6" args="(double lowerKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPointF QCPGraph::lowerFillBasePoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lowerKey</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by addFillBasePoints to conveniently assign the point which closes the fill polygon on the lower side of the zero-value-line parallel to the key axis. The logarithmic axis scale case is a bit special, since the zero-value-line in pixel coordinates is in positive or negative infinity. So this case is handled separately by just closing the fill polygon on the axis which lies in the direction towards the zero value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerKey</td><td>pixel position of the lower key of the point. Depending on whether the key axis is horizontal or vertical, <em>lowerKey</em> will end up as the x or y value of the returned point, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a363d066c179e0f46cc93c12bafb0bfba"></a><!-- doxytag: member="QCPGraph::upperFillBasePoint" ref="a363d066c179e0f46cc93c12bafb0bfba" args="(double upperKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPointF QCPGraph::upperFillBasePoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upperKey</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by addFillBasePoints to conveniently assign the point which closes the fill polygon on the upper side of the zero-value-line parallel to the key axis. The logarithmic axis scale case is a bit special, since the zero-value-line in pixel coordinates is in positive or negative infinity. So this case is handled separately by just closing the fill polygon on the axis which lies in the direction towards the zero value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">upperKey</td><td>pixel position of the upper key of the point. Depending on whether the key axis is horizontal or vertical, <em>upperKey</em> will end up as the x or y value of the returned point, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0374b7268e35cab9802a6be2b5d726d7"></a><!-- doxytag: member="QCPGraph::getChannelFillPolygon" ref="a0374b7268e35cab9802a6be2b5d726d7" args="(const QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QPolygonF QCPGraph::getChannelFillPolygon </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates the polygon needed for drawing channel fills between this graph (data passed via <em>lineData</em>) and the graph specified by mChannelFillGraph (data generated by calling its <a class="el" href="classQCPGraph.html#af66183533a29520be3e74489ad1449cc">getPlotData</a> function). May return an empty polygon if the key ranges have no overlap or fill target graph and this graph don't have same orientation (i.e. both key axes horizontal or both key axes vertical). For increased performance (due to implicit sharing), keep the returned QPolygonF const. </p>

</div>
</div>
<a class="anchor" id="a6f4e9461d5925be9228fc4760249a04f"></a><!-- doxytag: member="QCPGraph::findIndexBelowX" ref="a6f4e9461d5925be9228fc4760249a04f" args="(const QVector&lt; QPointF &gt; *data, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QCPGraph::findIndexBelowX </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the greatest index of <em>data</em>, whose points x value is just below <em>x</em>. Assumes x values in <em>data</em> points are ordered ascending, as is the case when plotting with horizontal key axis. Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="abab2a75b5e63630432bdd1f3b57f07fa"></a><!-- doxytag: member="QCPGraph::findIndexAboveX" ref="abab2a75b5e63630432bdd1f3b57f07fa" args="(const QVector&lt; QPointF &gt; *data, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QCPGraph::findIndexAboveX </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the smallest index of <em>data</em>, whose points x value is just above <em>x</em>. Assumes x values in <em>data</em> points are ordered ascending, as is the case when plotting with horizontal key axis. Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="a6c4d556de3d1e02f548401001f72c6ff"></a><!-- doxytag: member="QCPGraph::findIndexBelowY" ref="a6c4d556de3d1e02f548401001f72c6ff" args="(const QVector&lt; QPointF &gt; *data, double y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QCPGraph::findIndexBelowY </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the greatest index of <em>data</em>, whose points y value is just below <em>y</em>. Assumes y values in <em>data</em> points are ordered descending, as is the case when plotting with vertical key axis. Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="adf50243f1df203883a2187089734bfcb"></a><!-- doxytag: member="QCPGraph::findIndexAboveY" ref="adf50243f1df203883a2187089734bfcb" args="(const QVector&lt; QPointF &gt; *data, double y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int QCPGraph::findIndexAboveY </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the smallest index of <em>data</em>, whose points y value is just above <em>y</em>. Assumes y values in <em>data</em> points are ordered descending, as is the case when plotting with vertical key axis. Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="ab39c7e8c94b64804a8dc9c19bc7d4683"></a><!-- doxytag: member="QCPGraph::getKeyRange" ref="ab39c7e8c94b64804a8dc9c19bc7d4683" args="(bool &amp;validRange, SignDomain inSignDomain=sdBoth) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> QCPGraph::getKeyRange </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em> = <code>sdBoth</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by rescaleAxes functions to get the full data key bounds. For logarithmic plots, one can set <em>inSignDomain</em> to either <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> or <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030">sdPositive</a> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> and all positive points will be ignored for range calculation. For no restriction, just set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a> (default). <em>validRange</em> is an output parameter that indicates whether a proper range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa35b75b9032800d783df749c8a004ee9">rescaleAxes</a>, <a class="el" href="classQCPGraph.html#a9fc0c1288455fa5bb64b603d6b01de6c">getValueRange</a> </dd></dl>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#a7aa24ed0b3c39bd99338c7b9f145a71b">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc0c1288455fa5bb64b603d6b01de6c"></a><!-- doxytag: member="QCPGraph::getValueRange" ref="a9fc0c1288455fa5bb64b603d6b01de6c" args="(bool &amp;validRange, SignDomain inSignDomain=sdBoth) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> QCPGraph::getValueRange </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em> = <code>sdBoth</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by rescaleAxes functions to get the full data value bounds. For logarithmic plots, one can set <em>inSignDomain</em> to either <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> or <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030">sdPositive</a> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> and all positive points will be ignored for range calculation. For no restriction, just set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a> (default). <em>validRange</em> is an output parameter that indicates whether a proper range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa35b75b9032800d783df749c8a004ee9">rescaleAxes</a>, <a class="el" href="classQCPGraph.html#ab39c7e8c94b64804a8dc9c19bc7d4683">getKeyRange</a> </dd></dl>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#aed35cfebe5546feea7af2638dd869d5f">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a3a69fbbaea30050a9cfe335a9a01cbf2"></a><!-- doxytag: member="QCPGraph::getKeyRange" ref="a3a69fbbaea30050a9cfe335a9a01cbf2" args="(bool &amp;validRange, SignDomain inSignDomain, bool includeErrors) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> QCPGraph::getKeyRange </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to specify whether the error bars should be included in the range calculation.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>getKeyRange(bool &amp;validRange, SignDomain inSignDomain) </dd></dl>

</div>
</div>
<a class="anchor" id="acdb1e7bb86fea2764b0adb104185832b"></a><!-- doxytag: member="QCPGraph::getValueRange" ref="acdb1e7bb86fea2764b0adb104185832b" args="(bool &amp;validRange, SignDomain inSignDomain, bool includeErrors) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> QCPGraph::getValueRange </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to specify whether the error bars should be included in the range calculation.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>getValueRange(bool &amp;validRange, SignDomain inSignDomain) </dd></dl>

</div>
</div>
<a class="anchor" id="ab79c7ba76bc7fa89a4b3580e12149f1f"></a><!-- doxytag: member="QCPGraph::setName" ref="ab79c7ba76bc7fa89a4b3580e12149f1f" args="(const QString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::setName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The name is the textual representation of this plottable as it is displayed in the <a class="el" href="classQCPLegend.html" title="Manages a legend inside a QCustomPlot.">QCPLegend</a> of the parent <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>. It may contain any utf-8 characters, including newlines. </p>

</div>
</div>
<a class="anchor" id="a35c6325a2addc2e1a60b421c40357010"></a><!-- doxytag: member="QCPGraph::setVisible" ref="a35c6325a2addc2e1a60b421c40357010" args="(bool visible)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the plottable visibility is set to false, it won't be drawn to the plot surface. It will still appear in a <a class="el" href="classQCPLegend.html">QCPLegend</a> that it's associated with, though. </p>

</div>
</div>
<a class="anchor" id="ab74b09ae4c0e7e13142fe4b5bf46cac7"></a><!-- doxytag: member="QCPGraph::setPen" ref="ab74b09ae4c0e7e13142fe4b5bf46cac7" args="(const QPen &amp;pen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::setPen </td>
          <td>(</td>
          <td class="paramtype">const QPen &amp;&#160;</td>
          <td class="paramname"><em>pen</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The pen is used to draw basic lines that make up the plottable representation in the plot.</p>
<p>For example, the <a class="el" href="classQCPGraph.html">QCPGraph</a> subclass draws its graph lines and scatter points with this pen.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a4b92144dca6453a1f0f210e27edc74"></a><!-- doxytag: member="QCPGraph::setBrush" ref="a7a4b92144dca6453a1f0f210e27edc74" args="(const QBrush &amp;brush)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::setBrush </td>
          <td>(</td>
          <td class="paramtype">const QBrush &amp;&#160;</td>
          <td class="paramname"><em>brush</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.</p>
<p>For example, the <a class="el" href="classQCPGraph.html">QCPGraph</a> subclass draws the fill under the graph with this brush, when it's not set to Qt::NoBrush.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8524fa2994c63c0913ebd9bb2ffa3920"></a><!-- doxytag: member="QCPGraph::setKeyAxis" ref="a8524fa2994c63c0913ebd9bb2ffa3920" args="(QCPAxis *axis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::setKeyAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The key axis of a plottable can be set to any axis of a <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>, as long as it is orthogonal to the plottable's value axis. The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and the y-axis (QCustomPlot::yAxis) as value axis.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a71626a07367e241ec62ad2c34baf21cb">setValueAxis</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71626a07367e241ec62ad2c34baf21cb"></a><!-- doxytag: member="QCPGraph::setValueAxis" ref="a71626a07367e241ec62ad2c34baf21cb" args="(QCPAxis *axis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::setValueAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The value axis of a plottable can be set to any axis of a <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>, as long as it is orthogonal to the plottable's key axis. The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and the y-axis (QCustomPlot::yAxis) as value axis.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a8524fa2994c63c0913ebd9bb2ffa3920">setKeyAxis</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e8fc3be43c27ccacd70a7bf9d74a5cd"></a><!-- doxytag: member="QCPGraph::rescaleAxes" ref="a7e8fc3be43c27ccacd70a7bf9d74a5cd" args="(bool onlyEnlarge=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::rescaleAxes </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em> = <code>false</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all entities of the plottable that lie outside of that domain.</p>
<p><em>onlyEnlarge</em> makes sure the ranges are only expanded, never reduced. So it's possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has <em>onlyEnlarge</em> set to false (the default), and all subsequent set to true. </p>

</div>
</div>
<a class="anchor" id="a1acecfcca3e7fcda00fcbaa3c886386f"></a><!-- doxytag: member="QCPGraph::rescaleKeyAxis" ref="a1acecfcca3e7fcda00fcbaa3c886386f" args="(bool onlyEnlarge=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::rescaleKeyAxis </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em> = <code>false</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rescales the key axis of the plottable so the whole plottable is visible.</p>
<p>See <a class="el" href="classQCPAbstractPlottable.html#a7e8fc3be43c27ccacd70a7bf9d74a5cd">rescaleAxes</a> for detailed behaviour. </p>

</div>
</div>
<a class="anchor" id="abfd0805eb1d955c0111a990246658324"></a><!-- doxytag: member="QCPGraph::rescaleValueAxis" ref="abfd0805eb1d955c0111a990246658324" args="(bool onlyEnlarge=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::rescaleValueAxis </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em> = <code>false</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rescales the value axis of the plottable so the whole plottable is visible.</p>
<p>See <a class="el" href="classQCPAbstractPlottable.html#a7e8fc3be43c27ccacd70a7bf9d74a5cd">rescaleAxes</a> for detailed behaviour. </p>

</div>
</div>
<a class="anchor" id="a495a73911dbd0333fd147fddd515f516"></a><!-- doxytag: member="QCPGraph::addToLegend" ref="a495a73911dbd0333fd147fddd515f516" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCPAbstractPlottable::addToLegend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds this plottable to the legend of the parent <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>.</p>
<p>Normally, a <a class="el" href="classQCPPlottableLegendItem.html" title="A legend item representing a plottable with an icon and the plottable name.">QCPPlottableLegendItem</a> is created and inserted into the legend. If the plottable needs a more specialized representation in the plot, this function will take this into account and instead create the specialized subclass of <a class="el" href="classQCPAbstractLegendItem.html" title="The abstract base class for all items in a QCPLegend.">QCPAbstractLegendItem</a>.</p>
<p>Returns true on success, i.e. when a legend item associated with this plottable isn't already in the legend.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#aa1f350e510326d012b9a9c9249736c83">removeFromLegend</a>, <a class="el" href="classQCPLegend.html#a3ab274de52d2951faea45a6d975e6b3f">QCPLegend::addItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa1f350e510326d012b9a9c9249736c83"></a><!-- doxytag: member="QCPGraph::removeFromLegend" ref="aa1f350e510326d012b9a9c9249736c83" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool QCPAbstractPlottable::removeFromLegend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the plottable from the legend of the parent <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>. This means the <a class="el" href="classQCPAbstractLegendItem.html" title="The abstract base class for all items in a QCPLegend.">QCPAbstractLegendItem</a> (usually a <a class="el" href="classQCPPlottableLegendItem.html" title="A legend item representing a plottable with an icon and the plottable name.">QCPPlottableLegendItem</a>) that is associated with this plottable is removed.</p>
<p>Returns true on success, i.e. if a legend item associated with this plottable was found and removed from the legend.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a495a73911dbd0333fd147fddd515f516">addToLegend</a>, <a class="el" href="classQCPLegend.html#ac91595c3eaa746fe6321d2eb952c63bb">QCPLegend::removeItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade710a776104b14c1c835168ce1bfc5c"></a><!-- doxytag: member="QCPGraph::coordsToPixels" ref="ade710a776104b14c1c835168ce1bfc5c" args="(double key, double value, double &amp;x, double &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QCPAbstractPlottable::coordsToPixels </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience function for transforming a key/value pair to pixels on the <a class="el" href="classQCustomPlot.html" title="The central class which is also the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key becomes x or y).</p>
<p><em>key</em> and <em>value</em> are transformed to the coodinates in pixels and are written to <em>x</em> and <em>y</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAxis.html#a985ae693b842fb0422b4390fe36d299a">QCPAxis::coordToPixel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9fd1c9df8391781f05b0be22fbe91e13"></a><!-- doxytag: member="QCPGraph::coordsToPixels" ref="a9fd1c9df8391781f05b0be22fbe91e13" args="(double key, double value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QPointF QCPAbstractPlottable::coordsToPixels </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Returns the input as pixel coordinates in a QPointF. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAxis.html#a985ae693b842fb0422b4390fe36d299a">QCPAxis::coordToPixel</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qcustomplot_8h_source.html">qcustomplot.h</a></li>
<li>qcustomplot.cpp</li>
</ul>
</div>
<div class="footer" />Generated with <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.7.3</div>
</body>
</html>
